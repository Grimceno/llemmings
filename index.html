<!DOCTYPE html>
<html>
<head>
    <title>Lemmings Game</title>
    <style type="text/css">
        canvas {
            border: 1px solid black;
        }
    </style>


</head>
<body>

    <canvas id="canvas" width="800" height="600"></canvas>

  

<script type="text/javascript">
/*
Using plain javascript and canvas, let's create a level that looks and act like the game Lemmings. 
Specifics are:
- randomly generated textures using some noise function, the most important here is that it looks smooth and colorful
- randomly generated map using some noise function - the map should be drawn on a 960x960 canvas - it should be easy to do collision detection against the generated map.
- we want to draw the map
- need to implement all the types of lemmings (blocker, bomber, floater etc)
- we also want to make sure the lemmings automatically move and collide on the map, we want one of each type spawned on the map at start

Instead of giving me the implementation to everything right away, generate prompts I can give to you in 
portions to eventually get a full implemention. We have to do it this way because of the context window size. 
After each time you replied to a prompt, you should tell me what I should ask from you next. Also tell me what code I would need to include, if any, to get an answer.


---------------------
Like the game Lemmings, I want to procedurally generate a random map of platforms which the lemmings walk on.
The platforms are made of dirt, background color is black, here and there there should be water.
Also come up with a solution to efficiently do collision detection between lemmings and the map.

The map should be drawn on a canvas using plain javascript. Give me only the code, no explanation is needed other 
than comments in the code.
----

Like the game Lemmings, I want to procedurally generate a random map of platforms which the lemmings walk on.
The platforms are layered from top to bottom and are made of dirt, the background color is black, there is 
rock here and there. At the bottom there should water.
Use perlin noise with fractal brownian motion to generate the platforms and the rock. 
Make sure that we have some continuous platforms and not a map filled with randomness.

I'll draw an example map in ASCII:
|------------------------------------------|
|                  ####          ####      |
|  ================######       #######  # |
|                              ############|
|   ###      =========================#####|
|   ####                        ###########|
|   ####              =========== #########|
|   ####                           ########|
|   ###      =======================#######|
| ######                             ##### |
|%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%|

% is blue water
# is gray rock
| and - is canvas border
= is brown dirt platform

Just because the ASCII map is all squares, does not mean the elements of the map should be. In fact, the
map should look organic, mountainy and rough.

The API for the noise generator looks like this:
    const noiseGenerator = new ImprovedNoise();
    const noiseValue = noiseGenerator.noise(x * noiseScale * frequency, 0, 0) * 0.5 + 0.5;

The map should be drawn on a canvas using plain client-side javascript. Give me only the code, no explanation is needed other 
than comments in the code.
*/

class ImprovedNoise {
  constructor() {
    this.p = [];
    this.perm = [];
    this.xOff = 0;
    this.yOff = 0;
    this.zOff = 0;

    for (let i = 0; i < 256; i++) {
      this.p[i] = Math.floor(Math.random() * 256);
    }

    for (let i = 0; i < 512; i++) {
      this.perm[i] = this.p[i & 255];
    }
  }

  perlin(x, y, z) {
    const X = Math.floor(x) & 255;
    const Y = Math.floor(y) & 255;
    const Z = Math.floor(z) & 255;

    x -= Math.floor(x);
    y -= Math.floor(y);
    z -= Math.floor(z);

    const u = this.fade(x);
    const v = this.fade(y);
    const w = this.fade(z);

    const A = this.perm[X] + Y;
    const AA = this.perm[A] + Z;
    const AB = this.perm[A + 1] + Z;
    const B = this.perm[X + 1] + Y;
    const BA = this.perm[B] + Z;
    const BB = this.perm[B + 1] + Z;

    return this.lerp(
      w,
      this.lerp(v,
        this.lerp(u,
          this.grad(this.perm[AA], x, y, z),
          this.grad(this.perm[BA], x - 1, y, z)),
        this.lerp(u,
          this.grad(this.perm[AB], x, y - 1, z),
          this.grad(this.perm[BB], x - 1, y - 1, z))),
      this.lerp(v,
        this.lerp(u,
          this.grad(this.perm[AA + 1], x, y, z - 1),
          this.grad(this.perm[BA + 1], x - 1, y, z - 1)),
        this.lerp(u,
          this.grad(this.perm[AB + 1], x, y - 1, z - 1),
          this.grad(this.perm[BB + 1], x - 1, y - 1, z - 1)))
    );
  }

  grad(hash, x, y, z) {
    const h = hash & 15;
    const u = h < 8 ? x : y;
    const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
    return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
  }

  fade(t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
  }

  lerp(t, a, b) {
    return a + t * (b - a);
  }

  // Implementing the noise function here
  noise(x, y, z){
    // This function uses different frequency values but it can be defined as a paramenter if needed.
    const frequencyValues = [0.13, 0.16, 0.2, 0.25, 0.32, 0.4];
    
    let total = 0;
    let amplitude = 1;
    
    // Make the algorithm more flexible by accepting multiple frequency values
    for(let f of frequencyValues){
      total += this.perlin(x * f, y * f, z * f) * amplitude;
      amplitude *= 0.5; // Incremental frequency lowering.
    }

    return (total * 0.5) + 0.5; // Return a value between 0 and 1
  }
}
// Set canvas dimensions and context
const canvas = document.querySelector('canvas');
canvas.width = 800;
canvas.height = 600;
const ctx = canvas.getContext('2d');

// Set constants for noise generation
const noiseGenerator = new ImprovedNoise();
let noiseScale = 0.05; // adjust this to change the amount of detail in the noise
const frequency = 2.5;

// Set constants for map generation
const numPlatforms = 5; // adjust this to change the number of platforms
const platformHeight = canvas.height / numPlatforms;
const maxPlatformWidth = canvas.width * 0.5; // adjust this to change maximum platform width
const minPlatformWidth = canvas.width * 0.2; // adjust this to change minimum platform width
const rockProbability = 0.3; // adjust this to change the chance of generating rocks
const waterColor = '#0077be';
const rockColor = '#888888';
const dirtColor = '#4a2e00';

// Generate list of platforms
const platforms = [];
for (let i = 0; i < numPlatforms; i++) {
  const halfWidth = (Math.random() * (maxPlatformWidth - minPlatformWidth) + minPlatformWidth) / 2;
  const x = Math.random() * (canvas.width - halfWidth * 2) + halfWidth;
  const y = (i * platformHeight + platformHeight / 2) + platformHeight;     // add platformHeight so we don't have one at the very top
  platforms.push({x, y, halfWidth});
}

function drawMap() {
  // Create gradient for background color
  const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
  grd.addColorStop(0, '#111111');
  grd.addColorStop(1, '#444444');
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw water at bottom of canvas
  ctx.fillStyle = waterColor;
  ctx.fillRect(0, canvas.height - platformHeight, canvas.width, platformHeight);
  
  // Generate map using Perlin noise
  for (let i = platforms.length - 1; i >= 0; i--) {
    const platform = platforms[i];
    
    // Generate noise values for each pixel on the platform
    ctx.beginPath();
    ctx.moveTo(platform.x - platform.halfWidth, platform.y);
    for (let x = platform.x - platform.halfWidth; x <= platform.x + platform.halfWidth; x++) {
      const noiseValue = noiseGenerator.noise(x * noiseScale * frequency, 0, 0) * 0.5 + 0.5;
      const height = platform.y - noiseValue * platformHeight / 1.5;    // platform height divisor
      
      // Determine whether to draw dirt or rock based on probability
      if (Math.random() < rockProbability) {
        ctx.fillStyle = rockColor;
      } else {
        ctx.fillStyle = dirtColor;
      }
      ctx.lineTo(x, height);
    }
    ctx.lineTo(platform.x + platform.halfWidth, platform.y);
    ctx.closePath();
    ctx.fill();
  }
}

// call drawMap function to generate map
drawMap();


// =============== texture
/*
>>> Sadly I forgot to save the prompt for generating the "textures". :/


*/
noiseScale = 0.05; // controls zoom level
const numOctaves = 4;
const persistence = 0.5; // controls roughness
const width = canvas.width;
const height = canvas.height;

// Create a blank image to draw onto (actually, copy existing image ...)
let oldImgData = ctx.getImageData(0,0,width,height);    // TODO: This should be renamed, but I don't want to do it now since it would make some prompts invalid (for demonstration purposes). It does nicely illustrate the example of the need to keep track of these things.
let canvasBytes = Uint8ClampedArray.from(oldImgData.data);
const imgData = new ImageData(canvasBytes, width, height);

function getPixelColor(imageData, x, y) {
    x = Math.round(x);
    y = Math.round(y);
  const index = ((y * width) + x) * 4;
  const r = imageData.data[index];
  const g = imageData.data[index + 1];
  const b = imageData.data[index + 2];
  const a = imageData.data[index + 3];

  return [r, g, b, a];
}

function pixelIsColor(imageData, x, y, color, debug) {
    x = Math.round(x);
    y = Math.round(y);
  
  const [r, g, b, alpha] = getPixelColor(imageData, x, y);

  if(r === undefined) {
    console.warn("Should not happen:", "lemming:", debug, "len:", lemmings.length, "image:", imageData, r, g, b, alpha, "x:"+x, "y:"+y, "comparing:"+color, "index:"+Math.floor((y * width + x) * 4));
    debug.draw();
    throw "This should not happen"
  }

  return r === color[0] && g === color[1] && b === color[2];
}

if(true) {

    // Loop over each pixel in the image
    for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
        const pixelOffset = ((y * width) + x) * 4; // x2 for RGBA channels

        const isRock = pixelIsColor(imgData, x, y, [0x88, 0x88, 0x88, 255]);
        const isDirt = pixelIsColor(imgData, x, y, [0x4a, 0x2e, 0x00, 255]);

        if(!isRock && !isDirt) {
            // console.log("skipping");
            continue;
        }


        // Calculate value of noise at this pixel
        let noiseValue = 0;
        for (let octave = 1; octave <= numOctaves; octave++) {
        const frequency = Math.pow(2, octave);
        const amplitude = Math.pow(persistence, octave);
        noiseValue += noiseGenerator.noise(x * noiseScale * frequency,
                                            y * noiseScale * frequency,
                                            0) * amplitude;
        }
        noiseValue = (noiseValue * 0.5) + 0.5; // normalise between 0 and 1

        // Use noise value to determine pixel color
        let r, g, b;
        if (isRock) { // rock color
        const shade = noiseValue + (Math.random() * 0.2);
        r = shade * 90;
        g = shade * 90;
        b = shade * 90;
        } else { // dirt color
        const shade = noiseValue + (Math.random() * 0.2) - 0.4;
        r = shade * 120;
        g = shade * 100;
        b = shade * 80;
        }

        // Set the pixel color in the image data buffer
        imgData.data[pixelOffset] = r;   // Red channel
        imgData.data[pixelOffset+1] = g; // Green channel
        imgData.data[pixelOffset+2] = b; // Blue channel
        imgData.data[pixelOffset+3] = 255; // Alpha channel (255 for opaque)
    }
    }

    // Draw final image to canvas
    ctx.putImageData(imgData, 0, 0);

}

// ============== lemming sprite
/*
>>> New prompt for collision detection and lemming movement.

We are making a game like Lemmings, there is existing code.

The following are the relevant bits and are already declared in the program:
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
variable oldImgData is all pixel data gotten with ctx.getImageData()
function pixelIsColor(imageData, x, y, color): used to get compare a color of a pixel, x and y is canvas coorindate 
function getPixelColor(imageData, x, y) is used to get the color of a pixel, x and y is canvas coorindate 

The colors of various pixels are already declared:
waterColor = '#0077be';
rockColor = '#888888';
dirtColor = '#4a2e00';

The pixelIsColor() and getPixelColor() take an array of the four color components as the color argument. Figure it out.
Declare NEW constants for the colors as bytes like this: for e.g. waterColor; const waterColorBytes = [0x00, 0x77, 0xbe] ...

Using the above:
Do pixel perfect collision detection for a sprite that looks like a blue lemming with green hair 
(a blue box and a green box, basically), give it its own structure with position, velocity, etc.

It should move around on a 2d canvas which has gravity (that is, when there is no ground under it, 
it should fall down). If it runs in to an obstacle on the x axis (or the edge of the canvas) it should
turn around and walk the other way. The ground (dirt and rock) can be a bit hilly,
so there should be some fuzziness in the collision, it only stops when it runs into a tall obstacle.
If it falls into something on the y axis it should stop failling and start walking on the x axis.
If it falls into the water or went outside of canvas, the lemming is dead. Remember to check against
canvas bounds so that we don't try to get pixel data that does not exist.

Updates should be done every frame. There will eventually be many lemmings, so do note that they are
not controlled by keys, they move by themselves and is constrained by the collision rules outlined above.

It is important that you use the declared things I mentioned above. Just give me the code with
minor comments and be brief, don't explain anything with plain text.
*/

/*
Thought: It could be interesting to ask "There is already a lot of existing functionality; which bits of the existing program do you need to know about to implement the following:"
...or so
*/

/*
>>>>> New prompt: we need to make it so that a lemming adjusts on Y axis when it moves on X axis (it's hilly!)

In a game, given the below update function of a sprite walking on ground. The sprite should adjust
itself on the Y axis automatically (both up and down) as it is a bit hilly ground. Right now it just walks in a straight
line. Note that the ground underneath can be either dirt or rock. 

I don't need explanation of the code, I need you to fix the code.

*/

const blueBox = [0x00, 0x00, 0xff];
const greenBox = [0x00, 0xff, 0x00];
const GRAVITY = 0.03; // Adjust this until falling looks good
const lemmings = [];

const waterColorBytes = [0x00, 0x77, 0xbe]; // [0, 119, 190];
const rockColorBytes  = [0x88, 0x88, 0x88]; // [136, 136, 136];
const dirtColorBytes  = [0x4a, 0x2e, 0x00]; // [74, 46, 0];


let lastLemmingId = 0;

const Lemming = {
  id: -49152,
  age: 0,
  x: 0,
  y: 0,
  width: 20,
  height: 20,
  velX: 0,
  velY: 0,
  onGround: false,
  isDead: false,
  background: { },
  update: function() {
    if(this.y >= (canvas.height - (this.height+this.velY+1))) {
        this.isDead = true;
        return;
    }

    // Check if ground is under us or not
    let isGroundUnderneath = pixelIsColor(oldImgData, this.x + this.width / 2, this.y + this.height + 2, dirtColorBytes) || 
                            pixelIsColor(oldImgData, this.x + this.width / 2, this.y + this.height + 2, rockColorBytes);

    let heightAdjustment = 0;
    if (isGroundUnderneath) {
        let distanceToGround = 0;

        while (pixelIsColor(oldImgData, this.x + this.width / 2, this.y + (this.height/2) + distanceToGround + 2, dirtColorBytes)
            || pixelIsColor(oldImgData, this.x + this.width / 2, this.y + (this.height/2) + distanceToGround + 2, rockColorBytes)) {
            distanceToGround++;
        }

        heightAdjustment = distanceToGround; // subtract half the sprite's height
    }

    // Check if we hit a wall on the x axis
    const hitWallOnLeft =
        pixelIsColor(oldImgData, this.x - 1, this.y + this.height / 2, dirtColorBytes) ||
        pixelIsColor(oldImgData, this.x - 1, this.y + this.height / 2, rockColorBytes);
    const hitWallOnRight =
        pixelIsColor(oldImgData, this.x + this.width + 1, this.y + this.height / 2, dirtColorBytes) ||
        pixelIsColor(oldImgData, this.x + this.width + 1, this.y + this.height / 2, rockColorBytes); 
    
    // Check if we've fallen in water
    const isWaterBelow =
        pixelIsColor(oldImgData, this.x + this.width / 2, this.y + this.height + 1, waterColorBytes);
    
    // Update velocity according to the collision rules
    if (!this.onGround) {
      this.velY += GRAVITY;
      
      if (isGroundUnderneath) {
        this.onGround = true;
        this.velY = 0;
      }
    } else if (this.onGround && !isGroundUnderneath) {
      // Start falling if there's no ground
      this.onGround = false;
    }
    
    if (hitWallOnLeft || hitWallOnRight || this.x <= this.width || this.x >= canvas.width-this.width) {
      this.velX *= -1;
    }
    
    if (isWaterBelow || this.y >= canvas.height-this.height) {
      this.isDead = true;
      console.log(this.id, "should die");
    }

    // Apply height adjustment
    if (heightAdjustment !== 0) {
        this.y -= heightAdjustment; // move sprite up
        console.log("Adjusted height:", this, heightAdjustment);
        // throw "Adjusted height"
    }
    
    // Move the lemming
    this.x += this.velX;
    this.y += this.velY;
    this.age++;
},

  
  draw: function() {
    // Draw the new lemming position
    ctx.fillStyle = 'rgb(' + blueBox.join(',') + ')';
    ctx.fillRect(this.x, this.y, this.width, this.height);
    ctx.fillStyle = 'rgb(' + greenBox.join(',') + ')';
    ctx.fillRect(this.x, this.y, 5 - 1, 5 - 1);
    ctx.fillRect(this.x + 15, this.y, 5 - 1, 5 - 1);

    // Debug
    ctx.strokeStyle = "white";
    ctx.strokeText(this.id, this.x + 1, this.y + 13)
  }

};

// Create a new lemming and add it to the array of lemmings
function spawnLemming() {
  if(isPaused) return;

  const newLemming = Object.create(Lemming);
  newLemming.id = ++lastLemmingId;
  newLemming.x = Math.random() * canvas.width; // Start at a random x location
  newLemming.y = 0;
//   newLemming.y = Math.random() * canvas.height / 4;
  newLemming.velX = 0.4; // Walk to the right by default
  lemmings.push(newLemming);
}


// Spawn a new lemming every second
// throw "arrr stop -- fix save/restore background"
setInterval(spawnLemming, 1000);

/*
>>> New prompt to fix: We don't want to clear entire context, just draw and restore what was changed (the lemming)

We're making a game (Lemmings), to optmize the drawing, I want to change something...

Instead of clearing entire canvas every frame and redrawing it, just redraw the lemming that moved.
Before the lemming was drawn, it needs to keep track of the background and restore that. Make sure
we do not get any memory leaks around keeping track of the previous background.

A lemming structure looks like this:
const lemming = {
  id: -49152,
  x: 0,
  y: 0,
  width: 20,
  height: 20,
  velX: 0,
  velY: 0,
  onGround: false,
  isDead: false,
  update: function () {  Do NOT change this function  }
  draw: function() {
    // Draw the blue box and green hair
    ctx.fillStyle = 'rgb(' + blueBox.join(',') + ')';
    ctx.fillRect(this.x, this.y, this.width, this.height);
    ctx.fillStyle = 'rgb(' + greenBox.join(',') + ')';
    ctx.fillRect(this.x, this.y, 5, 5);
    ctx.fillRect(this.x + 15, this.y, 5, 5);
  }
}

And the frame update currently looks like this:
function update() {
   ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Update and draw each lemming
  lemmings.forEach((lemming) => {
    lemming.update();
    lemming.draw();
    
    if (lemming.isDead) {
      // Remove dead lemmings from the array as optimization
      const index = lemmings.indexOf(lemming);
      lemmings.splice(index, 1);
      console.log("removing dead lemming");
    }
  });
  
  // Schedule the next frame
  requestAnimationFrame(update);
}

These variables are already declared, use them.
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

Do not use ctx.save() and ctx.restore() (you don't understand what they do). In essence, what you 
want to do is save the pixel data before you draw a lemming. Next frame you want to restore that, 
then draw the lemming at its new position. You probably should do all saving/restoring for all lemmings 
in one pass, then draw all lemmings. To avoid getting lemmings that move part of the background.
You may NOT change the lemming.update() method. 

It is important that you use the declared things I mentioned above and just give me the code with
minor comments -- be brief, don't explain anything in plain text.

==============
>>>>>>>>> VERSION 2 -- I had trouble making it understand that it should only update partial blocks -- so do entire canvas...
==============

Instead of clearing entire canvas every frame, make sure we draw back the background, and then the 
lemmings on top of that. Fix this method:

function update() {
   ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Update and draw each lemming
  lemmings.forEach((lemming) => {
    lemming.update();
    lemming.draw();
    
    if (lemming.isDead) {
      // Remove dead lemmings from the array as optimization
      const index = lemmings.indexOf(lemming);
      lemmings.splice(index, 1);
      console.log("removing dead lemming");
    }
  });
  // Schedule the next frame
  requestAnimationFrame(update);
}

Also tell me how I should get the background data before we get to our first update.
*/

/*
>>>>>> add a pause function on mouse click in the update function
update() code went here
*/

let background; // global variable to store canvas image data
let isPaused = false;

canvas.addEventListener('click', () => {
  isPaused = !isPaused;

  lemmings.forEach((lemming) => {
    console.log(
        lemming,
        getPixelColor(oldImgData, lemming.x + lemming.width / 2, lemming.y + lemming.height)
    );
  });
});

function getBackground() {
  background = ctx.getImageData(0, 0, canvas.width, canvas.height);
}

function update() {
  if (isPaused) {
    requestAnimationFrame(update);
    return;
  }
  // Restore the background
  ctx.putImageData(background, 0, 0);

  // Update and draw each lemming
  lemmings.forEach((lemming) => {
    lemming.update();
    lemming.draw();
    
    if (lemming.isDead) {
      // Remove dead lemmings from the array as optimization
      const index = lemmings.indexOf(lemming);
      lemmings.splice(index, 1);
      console.log("removing dead lemming");
    }
  });

  // Schedule the next frame
  requestAnimationFrame(update);
}

getBackground();

// Start the update loop
update();

</script>

</body>
</html>
