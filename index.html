<!DOCTYPE html>
<html>
<head>
    <title>Lemmings Game</title>
    <style type="text/css">
        canvas {
            border: 1px solid black;
        }
    </style>


</head>
<body>

    <canvas id="canvas" width="800" height="600"></canvas>

  

<script type="text/javascript">
/*
Using plain javascript and canvas, let's create a level that looks and act like the game Lemmings. 
Specifics are:
- randomly generated textures using some noise function, the most important here is that it looks smooth and colorful
- randomly generated map using some noise function - the map should be drawn on a 960x960 canvas - it should be easy to do collision detection against the generated map.
- we want to draw the map
- need to implement all the types of lemmings (blocker, bomber, floater etc)
- we also want to make sure the lemmings automatically move and collide on the map, we want one of each type spawned on the map at start

Instead of giving me the implementation to everything right away, generate prompts I can give to you in 
portions to eventually get a full implemention. We have to do it this way because of the context window size. 
After each time you replied to a prompt, you should tell me what I should ask from you next. Also tell me what code I would need to include, if any, to get an answer.


---------------------
Like the game Lemmings, I want to procedurally generate a random map of platforms which the lemmings walk on.
The platforms are made of dirt, background color is black, here and there there should be water.
Also come up with a solution to efficiently do collision detection between lemmings and the map.

The map should be drawn on a canvas using plain javascript. Give me only the code, no explanation is needed other 
than comments in the code.
----

Like the game Lemmings, I want to procedurally generate a random map of platforms which the lemmings walk on.
The platforms are layered from top to bottom and are made of dirt, the background color is black, there is 
rock here and there. At the bottom there should water.
Use perlin noise with fractal brownian motion to generate the platforms and the rock. 
Make sure that we have some continuous platforms and not a map filled with randomness.

I'll draw an example map in ASCII:
|------------------------------------------|
|                  ####          #         |
|  ================######       ##         |
|                              ####        |
|   ###      =========================     |
|   ####                        ###        |
|   ####              =========== ####     |
|   ####                           ####    |
|   ###      =======================#######|
| ######                             ##### |
|%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%|

% is blue water
# is gray rock
| and - is canvas border
= is brown dirt platform

Just because the ASCII map is all squares, does not mean the elements of the map should be. In fact, the
map should look organic, mountainy and rough.

The API for the noise generator looks like this:
    const noiseGenerator = new ImprovedNoise();
    const noiseValue = noiseGenerator.noise(x * noiseScale * frequency, 0, 0) * 0.5 + 0.5;

The map should be drawn on a canvas using plain client-side javascript. Give me only the code, no explanation is needed other 
than comments in the code.
*/

class ImprovedNoise {
  constructor() {
    this.p = [];
    this.perm = [];
    this.xOff = 0;
    this.yOff = 0;
    this.zOff = 0;

    for (let i = 0; i < 256; i++) {
      this.p[i] = Math.floor(Math.random() * 256);
    }

    for (let i = 0; i < 512; i++) {
      this.perm[i] = this.p[i & 255];
    }
  }

  perlin(x, y, z) {
    const X = Math.floor(x) & 255;
    const Y = Math.floor(y) & 255;
    const Z = Math.floor(z) & 255;

    x -= Math.floor(x);
    y -= Math.floor(y);
    z -= Math.floor(z);

    const u = this.fade(x);
    const v = this.fade(y);
    const w = this.fade(z);

    const A = this.perm[X] + Y;
    const AA = this.perm[A] + Z;
    const AB = this.perm[A + 1] + Z;
    const B = this.perm[X + 1] + Y;
    const BA = this.perm[B] + Z;
    const BB = this.perm[B + 1] + Z;

    return this.lerp(
      w,
      this.lerp(v,
        this.lerp(u,
          this.grad(this.perm[AA], x, y, z),
          this.grad(this.perm[BA], x - 1, y, z)),
        this.lerp(u,
          this.grad(this.perm[AB], x, y - 1, z),
          this.grad(this.perm[BB], x - 1, y - 1, z))),
      this.lerp(v,
        this.lerp(u,
          this.grad(this.perm[AA + 1], x, y, z - 1),
          this.grad(this.perm[BA + 1], x - 1, y, z - 1)),
        this.lerp(u,
          this.grad(this.perm[AB + 1], x, y - 1, z - 1),
          this.grad(this.perm[BB + 1], x - 1, y - 1, z - 1)))
    );
  }

  grad(hash, x, y, z) {
    const h = hash & 15;
    const u = h < 8 ? x : y;
    const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
    return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
  }

  fade(t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
  }

  lerp(t, a, b) {
    return a + t * (b - a);
  }

  // Implementing the noise function here
  noise(x, y, z){
    // This function uses different frequency values but it can be defined as a paramenter if needed.
    const frequencyValues = [0.13, 0.16, 0.2, 0.25, 0.32, 0.4];
    
    let total = 0;
    let amplitude = 1;
    
    // Make the algorithm more flexible by accepting multiple frequency values
    for(let f of frequencyValues){
      total += this.perlin(x * f, y * f, z * f) * amplitude;
      amplitude *= 0.5; // Incremental frequency lowering.
    }

    return (total * 0.5) + 0.5; // Return a value between 0 and 1
  }
}
// Set canvas dimensions and context
const canvas = document.querySelector('canvas');
canvas.width = 800;
canvas.height = 600;
const ctx = canvas.getContext('2d');

// Set constants for noise generation
const noiseGenerator = new ImprovedNoise();
let noiseScale = 0.05; // adjust this to change the amount of detail in the noise
const frequency = 1;

// Set constants for map generation
const numPlatforms = 10; // adjust this to change the number of platforms
const platformHeight = canvas.height / numPlatforms;
const maxPlatformWidth = canvas.width * 0.5; // adjust this to change maximum platform width
const minPlatformWidth = canvas.width * 0.2; // adjust this to change minimum platform width
const rockProbability = 0.3; // adjust this to change the chance of generating rocks
const waterColor = '#0077be';
const rockColor = '#888888';
const dirtColor = '#4a2e00';

// Generate list of platforms
const platforms = [];
for (let i = 0; i < numPlatforms; i++) {
  const halfWidth = (Math.random() * (maxPlatformWidth - minPlatformWidth) + minPlatformWidth) / 2;
  const x = Math.random() * (canvas.width - halfWidth * 2) + halfWidth;
  const y = i * platformHeight + platformHeight / 2;
  platforms.push({x, y, halfWidth});
}

function drawMap() {
  // Create gradient for background color
  const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
  grd.addColorStop(0, '#111111');
  grd.addColorStop(1, '#444444');
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Draw water at bottom of canvas
  ctx.fillStyle = waterColor;
  ctx.fillRect(0, canvas.height - platformHeight, canvas.width, platformHeight);
  
  // Generate map using Perlin noise
  for (let i = platforms.length - 1; i >= 0; i--) {
    const platform = platforms[i];
    
    // Generate noise values for each pixel on the platform
    ctx.beginPath();
    ctx.moveTo(platform.x - platform.halfWidth, platform.y);
    for (let x = platform.x - platform.halfWidth; x <= platform.x + platform.halfWidth; x++) {
      const noiseValue = noiseGenerator.noise(x * noiseScale * frequency, 0, 0) * 0.5 + 0.5;
      const height = platform.y - noiseValue * platformHeight;
      
      // Determine whether to draw dirt or rock based on probability
      if (Math.random() < rockProbability) {
        ctx.fillStyle = rockColor;
      } else {
        ctx.fillStyle = dirtColor;
      }
      ctx.lineTo(x, height);
    }
    ctx.lineTo(platform.x + platform.halfWidth, platform.y);
    ctx.closePath();
    ctx.fill();
  }
}

// call drawMap function to generate map
drawMap();


// =============== texture
noiseScale = 0.05; // controls zoom level
const numOctaves = 4;
const persistence = 0.5; // controls roughness
const width = canvas.width;
const height = canvas.height;

// Create a blank image to draw onto
const imgData = ctx.createImageData(width, height);


// Loop over each pixel in the image
for (let y = 0; y < height; y++) {
  for (let x = 0; x < width; x++) {
    // Calculate value of noise at this pixel
    let noiseValue = 0;
    for (let octave = 1; octave <= numOctaves; octave++) {
      const frequency = Math.pow(2, octave);
      const amplitude = Math.pow(persistence, octave);
      noiseValue += noiseGenerator.noise(x * noiseScale * frequency,
                                          y * noiseScale * frequency,
                                          0) * amplitude;
    }
    noiseValue = (noiseValue * 0.5) + 0.5; // normalise between 0 and 1

    // Use noise value to determine pixel color
    let r, g, b;
    if (noiseValue < 0.5) { // dirt color
      const shade = noiseValue + (Math.random() * 0.2);
      r = shade * 175;
      g = shade * 100;
      b = shade * 50;
    } else { // rock color
      const shade = noiseValue + (Math.random() * 0.2) - 0.4;
      r = shade * 120;
      g = shade * 100;
      b = shade * 80;
    }

    // Set the pixel color in the image data buffer
    const pixelOffset = ((y * width) + x) * 4; // x2 for RGBA channels
    imgData.data[pixelOffset] = r;   // Red channel
    imgData.data[pixelOffset+1] = g; // Green channel
    imgData.data[pixelOffset+2] = b; // Blue channel
    imgData.data[pixelOffset+3] = 255; // Alpha channel (255 for opaque)
  }
}

// Draw final image to canvas
ctx.putImageData(imgData, 0, 0);



  </script>
</body>
</html>



</script>

</body>
</html>
