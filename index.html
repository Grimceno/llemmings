<!DOCTYPE html>
<html>
<head>
    <title>Lemmings Game</title>
    <style type="text/css">
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="960" height="960"></canvas>
    
<script type="text/javascript">
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const mapWidth = 960;
const mapHeight = 960;

// Generate a 2D array of values between 0 and 1 using Perlin noise
function generateNoiseMap(width, height, scale) {
  const noiseMap = [];

  for (let y = 0; y < height; y++) {
    noiseMap[y] = [];

    for (let x = 0; x < width; x++) {
      // Normalize x,y to scale
      const nx = x / width - 0.5;
      const ny = y / height - 0.5;

      noiseMap[y][x] = noise(nx * scale, ny * scale);
    }
  }

  return noiseMap;
}

function noise(x, y) {
  // Math.floor() and & 255 are used for bitwise operation,
  // which provides improved performance over regular multiplication/division
  const xi = Math.floor(x) & 255;
  const yi = Math.floor(y) & 255;

    // Calculate the position inside each unit square
  const xf = x - Math.floor(x);
  const yf = y - Math.floor(y);

  // Generate a set of 4 random gradient vectors evenly distributed around the unit square
  const gradientVectors = new Array(4).fill().map((_, i) => {
    const angle = Math.PI / 2 * i;
    return [Math.cos(angle), Math.sin(angle)];
  });

  // Generate dot products between the distance vector and each of the gradient vectors for each surrounding vertex
  const dotProducts = new Array(4).fill().map((_, i) => {
    const dx = xf - (i === 1 || i === 2 ? 1 : 0);
    const dy = yf - (i === 2 || i === 3 ? 1 : 0);
    return dx * gradientVectors[i][0] + dy * gradientVectors[i][1];
  });

  // Interpolate the dot products to calculate the final value at (x, y) using Perlin's interpolation
  const u = fade(xf);
  const v = fade(yf);
  const top = interpolate(dotProducts[0], dotProducts[1], u);
  const bottom = interpolate(dotProducts[2], dotProducts[3], u);
  return interpolate(top, bottom, v);

}

// Fade function from Ken Perlin
function fade(t) {
  return (6 * t - 15) * t * t * t + 1;
}

// Linear interpolation function
function interpolate(a, b, x) {
  return a + x * (b - a);
}


// Draw terrain using the noise map
function drawTerrain(ctx, noiseMap) {
  const imageData = ctx.createImageData(noiseMap[0].length, noiseMap.length);

  for (let y = 0; y < noiseMap.length; y++) {
    for (let x = 0; x < noiseMap[y].length; x++) {
      const value = Math.floor(noiseMap[y][x] * 255);

      // Draw terrain tile based on value
      if (value <= 128) {
        imageData.data[(y * noiseMap[0].length + x) * 4 + 3] = 255;
      } else {
        imageData.data[(y * noiseMap[0].length + x) * 4] = value;
        imageData.data[(y * noiseMap[0].length + x) * 4 + 1] = value;
        imageData.data[(y * noiseMap[0].length + x) * 4 + 2] = value;
        imageData.data[(y * noiseMap[0].length + x) * 4 + 3] = 255;
      }
    }
  }

  ctx.putImageData(imageData, 0, 0);
}

// Generate and draw terrain
const noiseMap = generateNoiseMap(mapWidth, mapHeight, 0.54);
drawTerrain(ctx, noiseMap);

// Check if a point collides with the terrain
function pixelCollidesWithTerrain(x, y, noiseMap, tolerance = 0) {
  const mapX = Math.round(x);
  const mapY = Math.round(y);

  // If out of bounds, consider it a solid tile
  if (mapX < 0 || mapX >= noiseMap[0].length ||
      mapY < 0 || mapY >= noiseMap.length) {
    return true;
  }

  // Check if tile is solid
  return noiseMap[mapY][mapX] > 128 - tolerance;
}

// Move a sprite (including lemmings) and handle collisions
function moveSprite(sprite, dx, dy, noiseMap, tolerance = 0) {
  // Temporary move to check for collisions
  const tempSprite = { x: sprite.x + dx, y: sprite.y + dy, w: sprite.w, h: sprite.h };

  // Check the corners of the sprite for collisions
  const collides =
    pixelCollidesWithTerrain(tempSprite.x, tempSprite.y, noiseMap, tolerance) ||
    pixelCollidesWithTerrain(tempSprite.x + sprite.w, tempSprite.y, noiseMap, tolerance) ||
    pixelCollidesWithTerrain(tempSprite.x, tempSprite.y + sprite.h, noiseMap, tolerance) ||
    pixelCollidesWithTerrain(tempSprite.x + sprite.w, tempSprite.y + sprite.h, noiseMap, tolerance);

  if (!collides) {
    // Move sprite if no collision was detected
    sprite.x += dx;
    sprite.y += dy;
  }

  return !collides;
}



</script>

</body>
</html>
