<!DOCTYPE html>
<html>
<head>
    <title>Lemmings Game</title>
    <style type="text/css">
        canvas {
            border: 1px solid black;
        }
    </style>


</head>
<body>

    <canvas id="canvas" width="800" height="600"></canvas>

  

<script type="text/javascript">
/*
Using plain javascript and canvas, let's create a level that looks and act like the game Lemmings. 
Specifics are:
- randomly generated textures using some noise function, the most important here is that it looks smooth and colorful
- randomly generated map using some noise function - the map should be drawn on a 960x960 canvas - it should be easy to do collision detection against the generated map.
- we want to draw the map
- need to implement all the types of lemmings (blocker, bomber, floater etc)
- we also want to make sure the lemmings automatically move and collide on the map, we want one of each type spawned on the map at start

Instead of giving me the implementation to everything right away, generate prompts I can give to you in 
portions to eventually get a full implemention. We have to do it this way because of the context window size. 
After each time you replied to a prompt, you should tell me what I should ask from you next. Also tell me what code I would need to include, if any, to get an answer.


---------------------
Like the game Lemmings, I want to procedurally generate a random map of platforms which the lemmings walk on.
The platforms are made of dirt, background color is black, here and there there should be water.
Also come up with a solution to efficiently do collision detection between lemmings and the map.

The map should be drawn on a canvas using plain javascript. Give me only the code, no explanation is needed other 
than comments in the code.
----

Like the game Lemmings, I want to procedurally generate a random map of platforms which the lemmings walk on.
The platforms are layered from top to bottom and are made of dirt, the background color is black, there is 
rock here and there. At the bottom there should water.
Use perlin noise with fractal brownian motion to generate the platforms and the rock. 
Make sure that we have some continuous platforms and not a map filled with randomness.

I'll draw an example map in ASCII:
|------------------------------------------|
|                  ####          ####      |
|  ================######       #######  # |
|                              ############|
|   ###      =========================#####|
|   ####                        ###########|
|   ####              =========== #########|
|   ####                           ########|
|   ###      =======================#######|
| ######                             ##### |
|%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%|

% is blue water
# is gray rock
| and - is canvas border
= is brown dirt platform

Just because the ASCII map is all squares, does not mean the elements of the map should be. In fact, the
map should look organic, mountainy and rough.

The API for the noise generator looks like this:
    const noiseGenerator = new ImprovedNoise();
    const noiseValue = noiseGenerator.noise(x * noiseScale * frequency, 0, 0) * 0.5 + 0.5;

The map should be drawn on a canvas using plain client-side javascript. Give me only the code, no explanation is needed other 
than comments in the code.
*/

class ImprovedNoise {
  constructor() {
    this.p = [];
    this.perm = [];
    this.xOff = 0;
    this.yOff = 0;
    this.zOff = 0;

    for (let i = 0; i < 256; i++) {
      this.p[i] = Math.floor(Math.random() * 256);
    }

    for (let i = 0; i < 512; i++) {
      this.perm[i] = this.p[i & 255];
    }
  }

  perlin(x, y, z) {
    const X = Math.floor(x) & 255;
    const Y = Math.floor(y) & 255;
    const Z = Math.floor(z) & 255;

    x -= Math.floor(x);
    y -= Math.floor(y);
    z -= Math.floor(z);

    const u = this.fade(x);
    const v = this.fade(y);
    const w = this.fade(z);

    const A = this.perm[X] + Y;
    const AA = this.perm[A] + Z;
    const AB = this.perm[A + 1] + Z;
    const B = this.perm[X + 1] + Y;
    const BA = this.perm[B] + Z;
    const BB = this.perm[B + 1] + Z;

    return this.lerp(
      w,
      this.lerp(v,
        this.lerp(u,
          this.grad(this.perm[AA], x, y, z),
          this.grad(this.perm[BA], x - 1, y, z)),
        this.lerp(u,
          this.grad(this.perm[AB], x, y - 1, z),
          this.grad(this.perm[BB], x - 1, y - 1, z))),
      this.lerp(v,
        this.lerp(u,
          this.grad(this.perm[AA + 1], x, y, z - 1),
          this.grad(this.perm[BA + 1], x - 1, y, z - 1)),
        this.lerp(u,
          this.grad(this.perm[AB + 1], x, y - 1, z - 1),
          this.grad(this.perm[BB + 1], x - 1, y - 1, z - 1)))
    );
  }

  grad(hash, x, y, z) {
    const h = hash & 15;
    const u = h < 8 ? x : y;
    const v = h < 4 ? y : h === 12 || h === 14 ? x : z;
    return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
  }

  fade(t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
  }

  lerp(t, a, b) {
    return a + t * (b - a);
  }

  // Implementing the noise function here
  noise(x, y, z){
    // This function uses different frequency values but it can be defined as a paramenter if needed.
    const frequencyValues = [0.13, 0.16, 0.2, 0.25, 0.32, 0.4];
    
    let total = 0;
    let amplitude = 1;
    
    // Make the algorithm more flexible by accepting multiple frequency values
    for(let f of frequencyValues){
      total += this.perlin(x * f, y * f, z * f) * amplitude;
      amplitude *= 0.5; // Incremental frequency lowering.
    }

    return (total * 0.5) + 0.5; // Return a value between 0 and 1
  }
}
// Set canvas dimensions and context
const canvas = document.querySelector('canvas');
canvas.width = 800;
canvas.height = 600;
const ctx = canvas.getContext('2d');

// Set constants for noise generation
const noiseGenerator = new ImprovedNoise();
let noiseScale = 0.05; // adjust this to change the amount of detail in the noise
const frequency = 2.5;

// Set constants for map generation
const numPlatforms = 10; // adjust this to change the number of platforms
const platformHeight = canvas.height / numPlatforms;
const maxPlatformWidth = canvas.width * 0.5; // adjust this to change maximum platform width
const minPlatformWidth = canvas.width * 0.2; // adjust this to change minimum platform width
const rockProbability = 0.3; // adjust this to change the chance of generating rocks
const waterColor = '#0077be';
const rockColor = '#888888';
const dirtColor = '#4a2e00';

// Generate list of platforms
const platforms = [];
for (let i = 0; i < numPlatforms; i++) {
  const halfWidth = (Math.random() * (maxPlatformWidth - minPlatformWidth) + minPlatformWidth) / 2;
  const x = Math.random() * (canvas.width - halfWidth * 2) + halfWidth;
  const y = i * platformHeight + platformHeight / 2;
  platforms.push({x, y, halfWidth});
}

function drawMap() {
  // Create gradient for background color
  const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
  grd.addColorStop(0, '#111111');
  grd.addColorStop(1, '#444444');
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Draw water at bottom of canvas
  ctx.fillStyle = waterColor;
  ctx.fillRect(0, canvas.height - platformHeight, canvas.width, platformHeight);
  
  // Generate map using Perlin noise
  for (let i = platforms.length - 1; i >= 0; i--) {
    const platform = platforms[i];
    
    // Generate noise values for each pixel on the platform
    ctx.beginPath();
    ctx.moveTo(platform.x - platform.halfWidth, platform.y);
    for (let x = platform.x - platform.halfWidth; x <= platform.x + platform.halfWidth; x++) {
      const noiseValue = noiseGenerator.noise(x * noiseScale * frequency, 0, 0) * 0.5 + 0.5;
      const height = platform.y - noiseValue * platformHeight / 1.5;    // platform height divisor
      
      // Determine whether to draw dirt or rock based on probability
      if (Math.random() < rockProbability) {
        ctx.fillStyle = rockColor;
      } else {
        ctx.fillStyle = dirtColor;
      }
      ctx.lineTo(x, height);
    }
    ctx.lineTo(platform.x + platform.halfWidth, platform.y);
    ctx.closePath();
    ctx.fill();
  }
}

// call drawMap function to generate map
drawMap();


// =============== texture
noiseScale = 0.05; // controls zoom level
const numOctaves = 4;
const persistence = 0.5; // controls roughness
const width = canvas.width;
const height = canvas.height;

// Create a blank image to draw onto (actually, copy existing image ...)
let oldImgData = ctx.getImageData(0,0,width,height);
let foo = Uint8ClampedArray.from(oldImgData.data);
const imgData = new ImageData(foo, width, height);

function getPixelColor(imageData, x, y) {
  const index = (y * width + x) * 4;
  const r = imageData.data[index];
  const g = imageData.data[index + 1];
  const b = imageData.data[index + 2];
  const a = imageData.data[index + 3];

  return [r, g, b, a];
}

function pixelIsColor(imageData, x, y, color) {
  const [r, g, b, alpha] = getPixelColor(imageData, x, y);

  return r === color[0] && g === color[1] && b === color[2];
}


// Loop over each pixel in the image
for (let y = 0; y < height; y++) {
  for (let x = 0; x < width; x++) {
    const pixelOffset = ((y * width) + x) * 4; // x2 for RGBA channels

    if(!pixelIsColor(imgData, x, y, [0x4a, 0x2e, 0x00, 255] )) {
        // console.log("skipping");
        continue;
    }

    // Calculate value of noise at this pixel
    let noiseValue = 0;
    for (let octave = 1; octave <= numOctaves; octave++) {
      const frequency = Math.pow(2, octave);
      const amplitude = Math.pow(persistence, octave);
      noiseValue += noiseGenerator.noise(x * noiseScale * frequency,
                                          y * noiseScale * frequency,
                                          0) * amplitude;
    }
    noiseValue = (noiseValue * 0.5) + 0.5; // normalise between 0 and 1

    // Use noise value to determine pixel color
    let r, g, b;
    if (noiseValue < 0.5) { // dirt color
      const shade = noiseValue + (Math.random() * 0.2);
      r = shade * 175;
      g = shade * 100;
      b = shade * 50;
    } else { // rock color
      const shade = noiseValue + (Math.random() * 0.2) - 0.4;
      r = shade * 120;
      g = shade * 100;
      b = shade * 80;
    }

    // Set the pixel color in the image data buffer
    imgData.data[pixelOffset] = r;   // Red channel
    imgData.data[pixelOffset+1] = g; // Green channel
    imgData.data[pixelOffset+2] = b; // Blue channel
    imgData.data[pixelOffset+3] = 255; // Alpha channel (255 for opaque)
  }
}

// Draw final image to canvas
ctx.putImageData(imgData, 0, 0);

// ============== lemming sprite
/*
We are making a game like Lemmings, there is existing code. The relevant bits are:

The following is already declared in the program:
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
variable oldImgData is all pixel data gotten with ctx.getImageData()
function pixelIsColor(imageData, x, y, color): used to get compare a color of a pixel, x and y is canvas coorindate 
function getPixelColor(imageData, x, y) is used to get the color of a pixel, x and y is canvas coorindate 

The colors of various pixels are already delcared:
waterColor = '#0077be';
rockColor = '#888888';
dirtColor = '#4a2e00';

The pixelIsColor() and getPixelColor() take an array of the four color components as the color argument. Figure it out.
Declare NEW constants for the colors as bytes like this: for e.g. waterColor; const waterColorBytes = [0x00, 0x77, 0xbe] ...

Using the above:
Do collision detection for a sprite that looks a little like a blue lemming with green hair, give it
its own structure with position, velocity, etc. It should move around on a 2d canvas which has 
gravity (that is, when there is no ground under it, it should fall down). If it runs in to an 
obstacle on the x axis it should turn around and walk the other way. If it falls into something 
on the y axis it should stop moving on the Y axis and start walking on the x axis. If it falls 
into the water, the lemming is dead. Updates should be done every frame. There will eventually
be many lemmings, so do note that they are not controlled by keys, they move by themselves and is 
constrained by the collision rules outlined above.

Just give me the code with minor comments, no need to explain anything in plain text.
*/
// const canvas = document.getElementById("canvas");
// const ctx = canvas.getContext("2d");

// Declare constants for colors as bytes 
const waterColorBytes = [0x00, 0x77, 0xbe];
const rockColorBytes = [0x88, 0x88, 0x88];
const dirtColorBytes = [0x4a, 0x2e, 0x00];

// let oldImgData = ctx.getImageData();

// Sprite structure for the blue lemming with green hair with initial position and velocity.
let sprite = {
  x: 0,
  y: 0,
  vx: 0,
  vy: 0,
  width: 20,
  height: 30,
  color: [0x00, 0xff, 0xff] // blue lemming
};

// Gravity constant for Y axis movement
const gravity = 0.5;

function update() {
  // Update sprite position based on velocity.
  sprite.x += sprite.vx;
  sprite.y += sprite.vy;

  // Check if the sprite has collided on X axis with an obstacle.
  if (pixelIsColor(oldImgData, sprite.x + sprite.width, sprite.y + (sprite.height / 2), dirtColorBytes) || pixelIsColor(oldImgData, sprite.x, sprite.y + (sprite.height / 2), dirtColorBytes)) {
    sprite.vx *= -1; // Flip direction of lemming's movement on x-axis
  }

  // Check if sprite has collided with obstacle or water on the Y axis.
  if (pixelIsColor(oldImgData, sprite.x + (sprite.width / 2), sprite.y + sprite.height, dirtColorBytes) ||
      pixelIsColor(oldImgData, sprite.x + (sprite.width / 2), sprite.y + sprite.height, rockColorBytes) || 
      pixelIsColor(oldImgData, sprite.x + (sprite.width / 2), sprite.y + sprite.height, waterColorBytes)) {
    sprite.vy = 0; // Stop vertical movement
  } else {
    sprite.vy += gravity;
  }

  // If sprite falls into water, it is dead, stop movement entirely.
  if(pixelIsColor(oldImgData, sprite.x + (sprite.width / 2), sprite.y + sprite.height, waterColorBytes)) {
    sprite.vx = 0;
    sprite.vy = 0;
  }
  
  // Clear the canvas and draw the sprite in its updated position
//   ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = `rgb(${sprite.color.join(",")})`;
  ctx.fillRect(sprite.x, sprite.y, sprite.width, sprite.height);

  // Store current image data to be used in next update
  oldImgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
}

// Call update every frame
setInterval(update, 1000/60); // 60 fps


</script>
</body>
</html>



</script>

</body>
</html>
